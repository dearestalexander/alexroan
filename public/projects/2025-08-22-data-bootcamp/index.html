<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex Roan | Strategy and Operations Consulting</title>
    <link rel="icon" type="image/png" href="/assets/images/favicon_io/favicon.ico">
    <link href="/styles.css" rel="stylesheet">
    <script defer src="/script-posts.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Manrope:wght@200..800&family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Pacifico&family=Quattrocento:wght@400;700&display=swap" rel="stylesheet">

    <script src="https://kit.fontawesome.com/0c355a85b4.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <header class="header-ctr">
  <a href="#main" class="skip">Skip to main content</a>
  <p class="logo-ctr">
    <span class="logo-span-one">Hi,</span>
    <span class="logo-span-two">I'm Alex</span>
  </p>
  <nav>
    <ul role="list" class="nav-ul">
      <li><a class="nav-li" href="/">Home</a></li>
      <li><a class="nav-li" href="/about/alex/">About</a></li>
      <li><a class="nav-li" href="/projects/">Projects</a></li>
      <li><a class="nav-li" href="https://linktr.ee/alexanderroan">Socials</a></li>
    </ul>
  </nav>
</header>
    <div class="divider"></div>
    <main id="main" class="post-main">
      <div id="post-sidebar-toc-ctr"></div>
      <article class="post-article">
        <h1 class="post-title">dataexpert.io beginners bootcamp notes</h1>
        <p id="post-tag" class="post-tag"> project</p>
        <p class="post-att">by Alexander Roan on 22 Aug 2025
        <h2>Intro</h2>
<p>This is a quick reference for the <a href="https://www.dataexpert.io/">dataexpert.io</a> bootcamp run by Zach Wilson.</p>
<p>It's my draft notes, so there may be innacuracies or typos!</p>
<p>Last update: 23rd August 2025.</p>
<h2>NBA data</h2>
<p>The data is accessible in a datalake at <a href="https://www.dataexpert.io/query">dataexpert.io/query</a>.</p>
<p>You can also install locally with PostgreSQL and docker. It's not difficult to do. I found instructions in the <a href="https://github.com/DataExpert-io/data-engineer-handbook/tree/main/">handbook</a>.</p>
<p>Navigate to intermediate-bootcamp &gt; materials &gt; 1-dimensional-data-modelling &gt; README.md.</p>
<p>Some steps from lesson/lab 2 only work in the datalake.</p>
<h3>NBA summary of main tables</h3>
<ul>
<li>Games <code>games</code>:
<ul>
<li>List of games by date with summary information</li>
<li>Key fields:
<ul>
<li>Game id: <code>game_id</code></li>
<li>Date: <code>game_date_est</code></li>
<li>Season: <code>season</code></li>
<li>Various points totals (home, away, etc.)</li>
</ul>
</li>
</ul>
</li>
<li>Game details <code>game_details</code>:
<ul>
<li>Player details by game</li>
<li>Key fields:
<ul>
<li>Game id: <code>game_id</code>,</li>
<li>Team id: <code>team_id</code></li>
<li>Team city: <code>team_city</code></li>
<li>Player id: <code>player_id</code></li>
<li>Player_name: <code>player_name</code></li>
<li>Player points: <code>pts</code>
Player_seasons <code>player_seasons</code>:</li>
</ul>
</li>
<li>Player details per season
<ul>
<li>Key fields:</li>
<li>Player name: <code>player_name</code></li>
<li>Player age: <code>age</code></li>
<li>Player height: <code>height</code></li>
<li>Player weight: <code>weight</code></li>
<li>Player college: <code>college</code></li>
<li>Player games played: <code>gp</code></li>
<li>Player points: <code>pts</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>L1: GROUP BY, JOIN, and Common Table Expression</h2>
<h3>SQL keywords</h3>
<ul>
<li><code>SELECT</code>: select data from a database</li>
<li><code>WHERE</code>:  filter records</li>
<li>Conditionals
<ul>
<li><code>AND</code>:</li>
<li><code>OR</code>:</li>
</ul>
</li>
<li><code>GROUP BY</code>
<ul>
<li>Group rows that have the same values into summary rows</li>
<li>Often used with aggregates</li>
</ul>
</li>
<li><code>ORDER BY</code>
<ul>
<li>Add <code>DESC</code> to reverse order <code>ORDER BY details.pts DESC</code></li>
</ul>
</li>
<li><code>JOIN</code>: Join
<ul>
<li><code>ON</code>: specify field for join</li>
</ul>
</li>
<li><code>INSERT INTO</code>: insert new records in a table</li>
<li><code>DELETE</code>: delete existing records in a table</li>
<li><code>UPDATE</code>: modify the existing records in a table.</li>
<li>Keywords:
<ul>
<li><code>DISTINCT</code> to deduplicate (using 'GROUP BY' vs. 'DISTINCT'?)</li>
<li><code>AS</code> create new name for column or table</li>
</ul>
</li>
<li>Aggregates:
<ul>
<li><code>COUNT()</code>: return the number of rows that match a specified criteria</li>
<li><code>MAX()</code>: return the largest valu eof a selected column</li>
<li><code>MIN()</code>: return the smallest value of a selected column</li>
<li><code>SUM()</code>: return total sum of numeric column</li>
<li><code>AVG()</code>: return average of numeric column</li>
<li><code>ARRAY_AGG()</code>:
<ul>
<li>Consolidates values from multiple rows into a single array</li>
<li>Groups by specified <code>GROUP BY</code></li>
<li>Ordering in the array can be controlled by <code>ORDER BY</code></li>
<li>Combined with <code>DISTINCT</code> to collect only unique values</li>
<li>Supports <code>FILTER</code> to include only specific rows</li>
<li>Preserves original data types</li>
<li>Useful for generating JSON output.</li>
</ul>
</li>
<li><code>JOIN()</code>: combine rows of two or more tables</li>
<li>(INNER) JOIN: matching values in both tables</li>
<li>LEFT (OUTER) JOIN: all from left table, matches from the right table</li>
<li>RIGHT (OUTER) JOIN: all from the right, matches from the left table</li>
<li>FULL (OUTER) JOIN: all when there is a match in either left or right table</li>
</ul>
</li>
</ul>
<h3>SQL statements examples</h3>
<p>Select &amp; Where</p>
<pre><code class="language-SQL">SELECT * FROM Customers
WHERE Country='Mexico'; 
</code></pre>
<p>Group By</p>
<pre><code class="language-SQL">SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s); 
</code></pre>
<p>Join</p>
<pre><code class="language-SQL">SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;
</code></pre>
<h3>L1 walkthrough</h3>
<h4>1.1: Lookup player details</h4>
<p>Lookup player season data by age, college, pts, etc.</p>
<pre><code class="language-SQL">SELECT *
FROM bootcamp.nba_player_seasons 
WHERE (age &gt; 40  AND college = 'Florida') OR pts &gt; 30
LIMIT 50
</code></pre>
<h4>1.2: Aggregate player details</h4>
<p>Experiment with aggregations on player_seasons</p>
<pre><code class="language-SQL">/* Ex 2 */
SELECT country, 
  COUNT(*), 
  AVG(pts), 
  SUM(reb), 
  ARRAY_AGG(DISTINCT player_name)
FROM bootcamp.nba_player_seasons 
GROUP BY country
</code></pre>
<h4>1.3: Join games and game_details</h4>
<p>Use join to connect games and games_details</p>
<pre><code class="language-SQL">SELECT games.game_date_est, 
  games.season, 
  details.player_name, 
  details.pts
FROM bootcamp.nba_game_details AS details 
JOIN bootcamp.nba_games AS games
ON details.game_id = games.game_id
</code></pre>
<h4>1.4: Combine aggregations and joins</h4>
<p>Combine aggregations with joins.</p>
<pre><code class="language-SQL">SELECT games.season,
  details.player_name,
  SUM(details.pts) AS total_pts,
  COUNT(*) AS num_games
FROM game_details AS details
JOIN games
ON details.game_id = games.game_id
GROUP BY games.season, details.player_name
</code></pre>
<h4>1.5: Troubleshoot high scores</h4>
<p>Start by investigating a single player, add:</p>
<pre><code class="language-SQL">SELECT ARRAY_AGG(DISTINCT games.game_date_set_est)
WHERE details.player_name = 'LeBron James'
</code></pre>
<p>Next remove duplicates and filter games to exclude playoffs</p>
<ul>
<li>Get pts per player per game by de-duplicating game_details
<ul>
<li>Get max pts grouped by <code>player_name</code> and <code>game_id</code></li>
</ul>
</li>
<li>Get a list of unique games excl. games that happen after April 15 of next year
<ul>
<li>(cutting off before the playoffs)</li>
</ul>
</li>
<li>Join two CTEs on game_id, filter by 'Lebron James' and get some aggregates</li>
</ul>
<pre><code class="language-SQL">WITH deduped_details AS (
  SELECT 
    player_name,
    game_id,
    MAX(pts) as pts 
  FROM bootcamp.nba_game_details
  GROUP BY player_name, game_id
), deduped_games AS (
  SELECT DISTINCT 
    game_id,
    season,
    game_date_est
  FROM bootcamp.nba_games
  WHERE game_date_est &lt; DATE(CAST((season + 1) AS VARCHAR) || '-04-15')
)

SELECT games.season, 
  details.player_name,
  SUM(details.pts) as total_pts, 
  COUNT(*) as num_games
  ARRAY_AGG(DISTINCT games.game_date_est)
FROM deduped_details as details 
JOIN deduped_games as games
ON details.game_id = games.game_id
WHERE details.player_name = 'LeBron James'
GROUP BY games.season, details.player_name
</code></pre>
<h4>Alex comments</h4>
<p>If you want to double check games per month to validate playoffs are included</p>
<pre><code class="language-SQL">SELECT
  EXTRACT(MONTH FROM game_date_est) AS month,
  COUNT(*) AS games_count
FROM games
GROUP BY month
ORDER BY month;
</code></pre>
<p>If you want to validate there are duplicates in game_details</p>
<pre><code class="language-SQL">SELECT
  player_name, 
  game_id,
  COUNT(*) AS player_game_count
FROM game_details
GROUP BY player_name, game_id
HAVING COUNT(*) &gt; 1
ORDER BY payer_game_count DESC;
</code></pre>
<p>Join this back to table to see duplicate rows</p>
<pre><code class="language-SQL">SELECT *
FROM game_details
WHERE (player_name, game_id) IN (
  SELECT 
    player_name, 
    game_id
  FROM game_details
  GROUP BY player_name, game_id
  HAVING COUNT(*) &gt; 1
);
</code></pre>
<h2>L2: Common Table Expressions</h2>
<h3>Key points</h3>
<ul>
<li>Data engineering principles:
<ul>
<li>Filter as soon as you can to process the least amount of data</li>
</ul>
</li>
<li>SQL does not execute in order written. The order is:
<ul>
<li>FROM/JOIN &gt; WHERE &gt; GROUP BY / HAVING &gt; SELECT &gt; ORDER BY &gt; LIMIT</li>
</ul>
</li>
<li>This lesson illustrats how important ordering is important when using CTEs
<ul>
<li>Filter, then rank</li>
<li>Rank, then filter (different results)</li>
</ul>
</li>
</ul>
<h3>Set up steps</h3>
<ul>
<li>Before creating tables in dataexpert.io/query create your schema:
<ul>
<li>In the query tool click 'important' and note your schema</li>
<li>Run command <code>CREATE SCHEMA  &lt;schemaname&gt;</code></li>
</ul>
</li>
</ul>
<h3>SQL Storage structures</h3>
<p>Table</p>
<ul>
<li>Permanent storage (until Deleted)</li>
<li>If you need to 'materialise data'</li>
<li>(Zach loves tables)</li>
</ul>
<p>Temporary table</p>
<ul>
<li>Temporary storage, removed when a query finishes</li>
</ul>
<p>Sub query</p>
<ul>
<li>Not recommended for nested queries</li>
<li>Best used when returning a single number or result</li>
<li>Less easy to read due to name/alias at the end
<ul>
<li>Name/alias is optional? (details to be confirmed)</li>
</ul>
</li>
</ul>
<p>View</p>
<ul>
<li>Consider like a 'CTE with a name'</li>
<li>Useful for queries with logic</li>
<li>No storage, so they executes every time their query results are needed
<ul>
<li>One benefit over a table is the will pick up any changes</li>
</ul>
</li>
</ul>
<pre><code class="language-SQL">CREATE VIEW alex.players_better_than_lebron
SELECT * FROM player_seasons
WHERE pts &gt;  (SELECT MAX(pts) FROM player_seasons WHERE player_name = 'LeBron James')
</code></pre>
<p>Common table expression (CTE)</p>
<ul>
<li>Useful for complex queries</li>
<li>A CTE doesn't store data, it's not a temporary table
<ul>
<li>If referenced multiple times, it'll run multiple times</li>
</ul>
</li>
<li>Zach generally recommends CTEs over sub queries
<ul>
<li>Improved readibility (name comes first)</li>
</ul>
</li>
</ul>
<p>Materialised views</p>
<ul>
<li>Not frequently used in analytics</li>
</ul>
<h3>SQL Datatypes</h3>
<ul>
<li>VARCHAR (string - 'variable character')</li>
<li>DECIMAL (floating point)</li>
<li>TINYINT</li>
<li>SMALLINT</li>
<li>INTEGER</li>
<li>BIGINT</li>
</ul>
<h3>SQL Keywords</h3>
<ul>
<li><code>UNION ALL</code>: Join data from multiple selects in query results (appends)</li>
<li><code>CREATE TABLE</code>: Create table</li>
<li><code>EXPLAIN</code>:
<ul>
<li>Shows the query tree</li>
<li>Search for 'scan' to see table scans</li>
<li>Useful  to illustrate the difference querying with views vs. tables</li>
</ul>
</li>
<li><code>Rank()</code>: Add a column ranking results based on a specified field:
<ul>
<li><code>RANK() OVER (ORDER BY &lt;field&gt; DESC) as var_name</code></li>
</ul>
</li>
</ul>
<p>Datalake related</p>
<ul>
<li><code>DESCRIBE &lt;tablename&gt;</code></li>
<li><code>SHOW CREATE TABLE &lt;tablename&gt;</code></li>
<li><code>PARTITION BY</code></li>
</ul>
<h3>L2 walkthrough</h3>
<h4>2.1: Add a ranking to a table</h4>
<ul>
<li>Who has scored the most points in a season ever?</li>
<li>Use <code>RANK()</code> to add a new column assigning a rank</li>
</ul>
<pre><code class="language-SQL">SELECT
  player_name,
  pts,
  RANK() OVER (ORDER BY pts DESC) as rank
FROM bootcamp.nba_player_seasons
ORDER BY rank
</code></pre>
<h4>2.2: Attempt to filter the calculated rank with <code>WHERE</code></h4>
<ul>
<li>What if we wanted to get the top ten ranked players only?
<ul>
<li>Adding <code>WHERE rank &lt;=10</code> fails:</li>
<li>'ERROR:  column &quot;rank&quot; does not exist`</li>
<li>This is due to order in which SQL executes</li>
<li><code>WHERE</code> before <code>SELECT</code>, at which point rank isn't calculated</li>
</ul>
</li>
</ul>
<pre><code class="language-SQL">SELECT
  player_name,
  pts,
  RANK() OVER (ORDER BY pts DESC) as rank
FROM bootcamp.nba_player_seasons
WHERE rank &lt;=10
ORDER BY rank
</code></pre>
<h4>2.3: Use a CTE to add rank, then filter</h4>
<ul>
<li>This will effectively move the <code>SELECT</code> above the <code>WHERE</code></li>
<li>Consider it like a query within a query:
<ul>
<li>Query all players first to get rank column</li>
<li>Then query condition on rank column</li>
</ul>
</li>
<li>A CTE doesn't store data, it's not a temporary table</li>
<li>If referenced multiple times, it'll run multiple times</li>
</ul>
<pre><code class="language-SQL">WITH ranked_players AS (
  SELECT
    player_name,
    pts,
    RANK() OVER (ORDER BY pts DESC) as rank
  FROM bootcamp.nba_player_seasons
)

SELECT * FROM ranked_players
WHERE rank &lt;= 10
</code></pre>
<p>Alternatively subquery syntax can be used, but this is less readable due to name/sub at the end:</p>
<pre><code class="language-SQL">SELECT * FROM (
  SELECT
    player_name,
    pts,
    RANK() OVER (ORDER BY pts DESC) AS rank
    FROM bootcamp.nba_player__seasons
) sub
WHERE rank &lt;= 10
</code></pre>
<h4>2.4: Illustration of multiple executions of a CTE</h4>
<ul>
<li>Create a CTE</li>
<li>Query it twice, using <code>UNION ALL</code> to join results</li>
<li>Add <code>EXPLAIN</code> at the top to get the query plan, this shows:
<ul>
<li>Definition of CTE 'ranked_players'</li>
<li>1st execution 'CTE scan' for 'rank &lt;= 10</li>
<li>2nd execution 'CTE scan' for rank &lt;= 20</li>
</ul>
</li>
<li>This illustrates there is no long term storage and re-use of the 1st run</li>
</ul>
<pre><code class="language-SQL">EXPLAIN WITH ranked_players AS (
  SELECT
    player_name,
    pts,
    RANK() OVER (ORDER BY pts DESC) as rank
  FROM bootcamp.nba_player_seasons
)

SELECT * FROM ranked_players
WHERE rank &lt;= 10
UNION ALL

SELECT * FROM ranked players
WHERE rank &gt;= 100
</code></pre>
<h4>2.5: Create a table, and store intermediate results (vs. using CTE)</h4>
<ul>
<li>If not already done, create your schema
<ul>
<li>In dataquery.io, get your schema name from 'Important'</li>
<li>Then use: <code>CREATE SCHEMA &lt;yourschemaname&gt;</code></li>
<li>(replace with your username, for me it's 'dearestalexander')</li>
</ul>
</li>
<li>Create a table with the rankings
<ul>
<li>Same as the CTE but with <code>CREATE TABLE</code> rather than <code>WITH</code></li>
</ul>
</li>
</ul>
<pre><code class="language-SQL">CREATE TABLE dearestalexander.nba_players_ranked AS
SELECT
  player_name,
  pts,
  RANK() OVER (ORDER BY pts DESC) AS rank
FROM bootcamp.nba_player_seasons
</code></pre>
<p>Query the table:</p>
<pre><code class="language-SQL">SELECT * FROM dearestalexander.nba_players_ranked
  WHERE rank &lt;= 10
</code></pre>
<h4>2.6: Investigating data lake partitions (in dataexpert.io/query)</h4>
<p>Use <code>SHOW CREATE TABLE bootcamp.nba_player_seasons</code>, it should return the following, which shows it is partitioned on season:</p>
<pre><code class="language-CLI">CREATE TABLE academy.bootcamp.nba_player_seasons ( player_name varchar, age integer, height varchar, weight integer, college varchar, country varchar, draft_year varchar, draft_round varchar, draft_number varchar, gp double, pts double, reb double, ast double, netrtg double, oreb_pct double, dreb_pct double, usg_pct double, ts_pct double, ast_pct double, season integer ) WITH ( format = 'PARQUET', format_version = 1, location = 's3://zachwilsonsorganization-522/ce557692-2f28-41e8-8250-8608042d2acb/04ae3f4b-8516-4220-adad-6deaaa2582dc', object_store_layout_enabled = true, partitioning = ARRAY['season'] )
</code></pre>
<p>Compare with <code>SHOW CREATE TABLE dearestalexander.nba_players_ranked</code>, it should return the following, which shows no partitions:</p>
<pre><code class="language-CLI">CREATE TABLE academy.dearestalexander.nba_players_ranked ( player_name varchar, pts double, rank bigint ) WITH ( format = 'PARQUET', format_version = 2, location = 's3://zachwilsonsorganization-522/ce557692-2f28-41e8-8250-8608042d2acb/41b87fc5-fcf3-428f-a0fa-7c8c04d2f569', max_commit_retry = 4, object_store_layout_enabled = true )
</code></pre>
<p>This illustrates the bootcamp tables are partitioned.</p>
<ul>
<li>Note =ARRAY['seasons'] at the end of the bootcamp.nba_player_seasons</li>
<li>The data is split up by season</li>
<li>Tip 'think of partitions as folders'</li>
<li>This partition improves efficiency for season specific searches
<ul>
<li>A query doesn't have to work through the entire table of all seasons.</li>
</ul>
</li>
</ul>
<h4>2.7: Create an empty partitioned table &amp; use insert to update</h4>
<ul>
<li>Create players_ranked, but this time partitioned on season</li>
<li>This will only work in datalake?</li>
</ul>
<pre><code class="language-SQL">CREATE TABLE dearestalexander.players_ranked_partitioned (
  player_name VARCHAR, 
  pts DECIMAL,
  rank BIGINT,
  season SMALLINT
)
WITH (
  partitioning = ARRAY['season']
)
</code></pre>
<p>Use a CTE to insert data into the empty table</p>
<ul>
<li>Define a CTE as the way to update the table</li>
<li>Select from the CTE with a condition, this will update the table
<ul>
<li>We update only 2007 season data below</li>
</ul>
</li>
</ul>
<pre><code class="language-SQL">INSERT INTO dearestalexander.nba_players_ranked_partitioned
-- Use a CTE 
WITH players_ranked AS (
  SELECT 
    player_name, 
    pts, 
    RANK() OVER (ORDER BY pts DESC) AS rank,
    season
  FROM
    bootcamp.nba_player_seasons
)

SELECT * FROM players_ranked
WHERE  season = 2007 -- NOTE WHERE IS OUTSIDE CTE
</code></pre>
<p>Check the table:</p>
<pre><code class="language-SQL">SELECT * FROM dearestalexander.nba_players_ranked_partitioned 
WHERE season = 2007
</code></pre>
<p>This shows 2007 season data.</p>
<p>Try checking for rank number 1 in 2007:</p>
<pre><code class="language-SQL">SELECT * FROM dearestalexander.nba_players_ranked_partitioned 
WHERE season = 2007 AND rank = 1
</code></pre>
<p>This doesn't return any results:</p>
<ul>
<li>It's because rank is being applied to all data before the season condition
<ul>
<li><code>RANK()</code> is applied on bootcamp.nba_player_seasons</li>
<li>This updates our partitioned table with all seasons (partitioned by season)</li>
<li>Our select then pulls out only one season</li>
<li>That season doesn't have a no.1 rank (calculated across all seasons)</li>
</ul>
</li>
</ul>
<p>Delete the partition table data to try a different approach</p>
<p><code>DELETE FROM dearestalexander.nba_playeres_ranked_partitioned</code></p>
<p>Now, try moving the 'WHERE' inside the CTE:</p>
<ul>
<li>Update only 1 season data in the partitioned table</li>
<li>Calculate rank on that seasons data</li>
</ul>
<pre><code class="language-SQL">INSERT INTO dearestalexander.nba_players_ranked_partitioned
-- Use a CTE 
WITH players_ranked AS (
  SELECT 
    player_name, 
    pts, 
    RANK() OVER (ORDER BY pts DESC) AS rank,
    season
  FROM
    bootcamp.nba_player_seasons
  WHERE  season = 2007 -- MOVED WHERE inside the CTE
)

SELECT * FROM players_ranked
</code></pre>
<p>Try checking again for rank number 1 in 2007:</p>
<pre><code class="language-SQL">SELECT * FROM dearestalexander.nba_players_ranked_partitioned 
WHERE season = 2007 AND rank = 1
</code></pre>
<ul>
<li>This time you get the 2007 data with the no. 1 score.</li>
<li>The rankings are being calculated on filtered 2007 data</li>
</ul>

        <div class="post-comments flow">
          <strong>Share, comment/discuss</strong>
          <p>Share on 
            <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://alexroan.com/projects/2025-08-22-data-bootcamp/" target="_blank">LinkedIn</a>, 
            <a href="https://twitter.com/intent/tweet?url=https://alexroan.com/projects/2025-08-22-data-bootcamp/&text=dataexpert.io beginners bootcamp notes" target="_blank">X</a>, 
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://alexroan.com/projects/2025-08-22-data-bootcamp/" target="_blank">or Facebook</a>.
          </p>
          <div id="cusdis_thread"
            data-host="https://cusdis.com"
            data-app-id="acb35451-258e-4673-9949-4ca8681c63ab"
            data-page-id="/projects/2025-08-22-data-bootcamp/"
            data-page-url="/projects/2025-08-22-data-bootcamp/"
            data-page-title="dataexpert.io beginners bootcamp notes">
          </div>
          <script async defer src="https://cusdis.com/js/cusdis.es.js"></script>
        </div>
      </article>
    </main>
    <footer class="flow">
  <p class="footer-attribution">Website built by Alex Roan using HTML, CSS and <a href="https://www.11ty.dev/">11ty</a>, hosted on <a href="https://www.netlify.com/">Netflify</a></p>
</footer>
    <script></script>
  </body>
</html>
